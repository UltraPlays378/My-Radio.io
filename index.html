<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>React Radio</title>

  <!-- React + ReactDOM -->
  <script src="libs/react.development.js"></script>
  <script src="libs/react-dom.development.js"></script>

  <!-- Babel for JSX -->
  <script src="libs/babel.min.js"></script>

  <!-- GlitchJS -->
  <script src="libs/GlitchJS.js"></script>

  <style>
    body {
      background: black;
      color: white;
      font-family: Arial, sans-serif;
      padding: 20px;
    }

    button {
      margin-right: 10px;
      margin-top: 10px;
      padding: 6px 12px;
      background: #0ff;
      color: black;
      border: none;
      cursor: pointer;
      font-weight: bold;
      border-radius: 4px;
    }

    button:hover {
      background: #0cc;
    }
/* Status badge container */
.status-badge {
  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 10px;
  padding: 8px 14px;
  border-radius: 8px;
  color: #fff;
  font-weight: 600;
  overflow: hidden;
  min-width: 140px;
  box-sizing: border-box;
}

/* Layered gradient backgrounds */
.status-badge .status-bg {
  position: absolute;
  inset: 0;
  z-index: 0;
  transition: opacity 420ms ease-in-out;
  pointer-events: none;
}

/* Online gradient layer */
.status-badge .status-bg.online {
  background: linear-gradient(135deg, #00ff88, #009944);
  opacity: 0;
}

/* Offline gradient layer */
.status-badge .status-bg.offline {
  background: linear-gradient(135deg, #ff4444, #aa0000);
  opacity: 0;
}

/* When online, show online layer; when offline, show offline layer */
.status-badge.online .status-bg.online { opacity: 1; }
.status-badge.offline .status-bg.offline { opacity: 1; }

/* Foreground content sits above the backgrounds */
.status-badge .status-content {
  position: relative;
  z-index: 1;
  display: inline-flex;
  align-items: center;
  gap: 10px;
  width: 100%;
  justify-content: space-between;
}

/* Time styling */
.status-badge .status-time {
  opacity: 0.85;
  font-weight: 500;
  font-size: 0.95em;
}
    /* ---------------------------------------------------
       GLOBAL RANGE SLIDER (seek bar + volume base)
       --------------------------------------------------- */
    input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 6px;
      background: #555;
      border-radius: 3px;
      outline: none;
    }

    /* Seek bar track (red fill, grey remainder) */
    input[type="range"]::-webkit-slider-runnable-track {
      background: linear-gradient(
        to right,
        red var(--seek-fill, 0%),
        #555 var(--seek-fill, 0%)
      );
      height: 6px;
      border-radius: 3px;
    }

    /* Firefox track */
    input[type="range"]::-moz-range-track {
      background: #555;
      height: 6px;
      border-radius: 3px;
    }

    input[type="range"]::-moz-range-progress {
      background: red;
      height: 6px;
      border-radius: 3px;
    }

    /* ---------------------------------------------------
       SEEK BAR THUMBSTICK — HIDDEN (no circle)
       --------------------------------------------------- */
    input[type="range"].seek-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 0;
      height: 0;
      background: transparent;
      border: none;
    }

    input[type="range"].seek-slider::-moz-range-thumb {
      width: 0;
      height: 0;
      background: transparent;
      border: none;
    }

    /* ---------------------------------------------------
       VOLUME SLIDER THUMBSTICK — CIRCULAR RED
       --------------------------------------------------- */
    .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: red;
      border-radius: 50%;
      cursor: pointer;
      margin-top: -4px;
    }

    .volume-slider::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: red;
      border-radius: 50%;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">

/* ------------------ Online Status ------------------ */
function OnlineStatus() {
  const [isOnline, setIsOnline] = React.useState(Boolean(GlitchJS.isOnline));
  const [time, setTime] = React.useState(() => new Date());

  React.useEffect(() => {
    const tick = () => {
      setIsOnline(Boolean(GlitchJS.isOnline));
      setTime(new Date());
    };

    // Poll runtime flag frequently for realtime updates
    const interval = setInterval(tick, 250);
    // Also run once immediately
    tick();

    return () => clearInterval(interval);
  }, []);

  const formatted = time.toLocaleTimeString([], {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit"
  });

  return (
    <div
      className={`status-badge ${isOnline ? "online" : "offline"}`}
      role="status"
      aria-live="polite"
      aria-atomic="true"
      title={isOnline ? "Online" : "Offline"}
    >
      <div className="status-bg online" aria-hidden="true" />
      <div className="status-bg offline" aria-hidden="true" />
      <div className="status-content">
        <div>{isOnline ? "Online" : "Offline"}</div>
        <div className="status-time">{formatted}</div>
      </div>
    </div>
  );
}
/* ------------------ Audio Player ------------------ */
function AudioPlayer() {
const [audioSources, setAudioSources] = React.useState([]);

React.useEffect(() => {
  async function fetchReleases() {
    try {
      const res = await fetch(
        "https://api.github.com/repos/UltraPlays378/My-Radio.io/releases"
      );

      const releases = await res.json();

      const allSongs = [];

      releases.forEach(release => {
        release.assets.forEach(asset => {
          const name = asset.name.toLowerCase();
          if (
            name.endsWith(".mp3") ||
            name.endsWith(".wav") ||
            name.endsWith(".flac")
          ) {
            allSongs.push(asset.browser_download_url);
          }
        });
      });

      setAudioSources(allSongs);
    } catch (err) {
      console.error("Failed to fetch releases:", err);
    }
  }

  fetchReleases();
}, []);
  const audioRef = React.useRef(null);

  const [currentSrc, setCurrentSrc] = React.useState(null);
  const [duration, setDuration] = React.useState(0);
  const [currentTime, setCurrentTime] = React.useState(0);
  const [volume, setVolume] = React.useState(1);
  const [playbackRate, setPlaybackRate] = React.useState(1);

  const lastTrack = React.useRef(null);
  const recentTracks = React.useRef([]);

  const getSmartRandomTrack = () => {
    let pool = audioSources.filter(src => src !== lastTrack.current);

    if (recentTracks.current.length >= audioSources.length - 1) {
      recentTracks.current = [];
    }

    pool = pool.filter(src => !recentTracks.current.includes(src));

    const choice = pool[Math.floor(Math.random() * pool.length)];

    recentTracks.current.push(choice);
    lastTrack.current = choice;

    return choice;
  };

  const playRandom = () => {
    const next = getSmartRandomTrack();
    setCurrentSrc(next);
  };

  React.useEffect(() => {
    if (!currentSrc) return;
    const audio = audioRef.current;
    audio.src = currentSrc;
    audio.play();
  }, [currentSrc]);

  React.useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;
    // apply selected playback rate and try to disable pitch-preservation where supported
    audio.playbackRate = playbackRate;
    if ('preservesPitch' in audio) audio.preservesPitch = false;
    if ('mozPreservesPitch' in audio) audio.mozPreservesPitch = false;
    if ('webkitPreservesPitch' in audio) audio.webkitPreservesPitch = false;
  }, [playbackRate]);

  const onLoadedMetadata = () => {
    setDuration(audioRef.current.duration || 0);
  }; 

  const onTimeUpdate = () => {
    setCurrentTime(audioRef.current.currentTime);
  };

  const fmt = (sec) => {
    if (!sec || isNaN(sec)) return "0:00";
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    return `${m}:${s < 10 ? "0" : ""}${s}`;
  };

  const onSeek = (e) => {
    const audio = audioRef.current;
    const value = Number(e.target.value);
    audio.currentTime = (value / 1000) * duration;
  };

  const onVolume = (e) => {
    const v = Number(e.target.value);
    setVolume(v);
    audioRef.current.volume = v;
  };

  const togglePause = () => {
    const audio = audioRef.current;
    if (audio.paused) audio.play();
    else audio.pause();
  };

  const seekPercent = duration ? (currentTime / duration) * 100 : 0;

  return (
    <div>
      <h1>React Radio</h1>

      <p>Song playing: {currentSrc ? currentSrc.split("/").pop() : "None"}</p>

      <p>{fmt(currentTime)} / {fmt(duration)}</p>

      <button onClick={playRandom}>Start Radio</button>
      <button onClick={togglePause}>Pause / Resume</button>
      <button onClick={() => (audioRef.current.currentTime = 0)}>⏮ Back</button>
      <button onClick={playRandom}>⏭ Next</button>

      <br /><br />

      <label>Volume:</label>
      <input
        className="volume-slider"
        type="range"
        min="0"
        max="1"
        step="0.01"
        value={volume}
        onChange={onVolume}
        style={{
          width: "150px",
          marginLeft: "10px",
          "--seek-fill": `${volume * 100}%`
        }}
      />

      <br /><br />

<label>Speed/Pitch: <span>{playbackRate.toFixed(2)}x</span></label>
<input
  className="volume-slider"
  type="range"
  min="0.5"
  max="2"
  step="0.1"
  value={playbackRate}
  onChange={(e) => {
    const v = Number(e.target.value);
    setPlaybackRate(v);
    const audio = audioRef.current;
    if (!audio) return;
    audio.playbackRate = v;
    if ('preservesPitch' in audio) audio.preservesPitch = false;
    if ('mozPreservesPitch' in audio) audio.mozPreservesPitch = false;
    if ('webkitPreservesPitch' in audio) audio.webkitPreservesPitch = false;
  }}
  style={{
    width: "150px",
    marginLeft: "10px",
    "--seek-fill": `${((playbackRate - 0.5) / 1.5) * 100}%`
  }}
/>

      <br /><br />

      <input
        className="seek-slider"
        type="range"
        min="0"
        max="1000"
        value={duration ? (currentTime / duration) * 1000 : 0}
        onChange={onSeek}
        style={{
          width: "100%",
          "--seek-fill": `${seekPercent}%`
        }}
      />

      <audio
        ref={audioRef}
        onLoadedMetadata={onLoadedMetadata}
        onTimeUpdate={onTimeUpdate}
        onEnded={playRandom}
      />
    </div>
  );
}

/* ------------------ App Wrapper ------------------ */
function App() {
  return (
    <div>
      <OnlineStatus />
      <AudioPlayer />
    </div>
  );
}

/* ------------------ React Root ------------------ */
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);

  </script>
</body>
</html>
