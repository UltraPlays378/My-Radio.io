<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>React Radio — No Babel (Speed slider updated)</title>

  <!-- React + ReactDOM (local libs as in your project) -->
  <script src="libs/react.development.js"></script>
  <script src="libs/react-dom.development.js"></script>

  <!-- NOTE: Babel removed as requested -->

  <!-- GlitchJS (kept as you had it) -->
  <script src="libs/GlitchJS.js"></script>

  <style>
    /* -------------------------
       UI styles (kept intact)
       ------------------------- */
    html, body { height: 100%; margin: 0; }
    body { background: black; color: white; font-family: Arial, sans-serif; padding: 20px; box-sizing: border-box; }

    .app-container { max-width: 900px; margin: 0 auto; position: relative; }

    button {
      margin-right: 10px;
      margin-top: 10px;
      padding: 6px 12px;
      background: #0ff;
      color: black;
      border: none;
      cursor: pointer;
      font-weight: bold;
      border-radius: 4px;
    }

    /* Top-right floating status (READ-ONLY) */
    .floating-status {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 9999;
      background: rgba(0,0,0,0.6);
      color: #fff;
      border: 2px solid rgba(255,255,255,0.08);
      padding: 8px 12px;
      border-radius: 8px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      backdrop-filter: blur(6px);
      box-shadow: 0 6px 18px rgba(0,0,0,0.6);
      font-weight: 700;
      pointer-events: none; /* make it non-interactive */
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ffcc00;
      box-shadow: 0 0 8px rgba(255,204,0,0.6);
      flex: 0 0 auto;
    }

    .status-playing .status-dot { background: #00ff88; box-shadow: 0 0 10px rgba(0,255,136,0.6); }
    .status-paused .status-dot { background: #ff4444; box-shadow: 0 0 10px rgba(255,68,68,0.5); }

    .status-text { font-size: 0.95rem; opacity: 0.95; white-space: nowrap; }

    .status-badge { position: relative; display: inline-flex; align-items: center; gap: 10px; padding: 8px 14px; border-radius: 8px; color: #fff; font-weight: 600; overflow: hidden; min-width: 140px; box-sizing: border-box; margin-bottom: 16px; }
    .status-bg { position: absolute; inset: 0; z-index: 0; transition: opacity 420ms ease-in-out; pointer-events: none; }
    .status-bg.online { background: linear-gradient(135deg, #00ff88, #009944); opacity: 0; }
    .status-bg.offline { background: linear-gradient(135deg, #ff4444, #aa0000); opacity: 0; }
    .status-badge.online .status-bg.online { opacity: 1; }
    .status-badge.offline .status-bg.offline { opacity: 1; }
    .status-content { position: relative; z-index: 1; display: inline-flex; align-items: center; gap: 10px; width: 100%; justify-content: space-between; }
    .status-time { opacity: 0.85; font-weight: 500; font-size: 0.95em; }

    input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 6px;
      background: #555;
      border-radius: 3px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-runnable-track {
      background: linear-gradient(
        to right,
        red var(--seek-fill, 0%),
        #555 var(--seek-fill, 0%)
      );
      height: 6px;
      border-radius: 3px;
    }

    input[type="range"]::-moz-range-track { background: #555; height: 6px; border-radius: 3px; }
    input[type="range"]::-moz-range-progress { background: red; height: 6px; border-radius: 3px; }

    input[type="range"].seek-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 0; height: 0; background: transparent; border: none; }
    input[type="range"].seek-slider::-moz-range-thumb { width: 0; height: 0; background: transparent; border: none; }

    .volume-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: red; border-radius: 50%; cursor: pointer; margin-top: -4px; }
    .volume-slider::-moz-range-thumb { width: 14px; height: 14px; background: red; border-radius: 50%; cursor: pointer; }

    /* Ensure audio element is invisible */
    audio { display: none; }
  </style>
</head>
<body>
  <div id="root" class="app-container"></div>

  <script type="text/javascript">
  // ============================================================
  // React Radio — No Babel version
  // - JSX removed
  // - Comments, UI, core features, AudioPlayer, <styles>, <audio>, <script> preserved
  // - Uses React.createElement via helper `h`
  // - Speed/Pitch slider updated: min 0.10, step 0.05, max 2.00
  // ============================================================

  (function () {
    const h = React.createElement;

    /* Safe localStorage wrapper (handles private mode / exceptions) */
    var safeStorage = {
      get: function (key, fallback) {
        if (fallback === undefined) fallback = null;
        try {
          var v = localStorage.getItem(key);
          return v === null ? fallback : v;
        } catch (e) {
          console.warn("localStorage.get failed:", e);
          return fallback;
        }
      },
      set: function (key, value) {
        try {
          localStorage.setItem(key, String(value));
          return true;
        } catch (e) {
          console.warn("localStorage.set failed:", e);
          return false;
        }
      }
    };

    /* ------------------ OnlineStatus component ------------------ */
    function OnlineStatus() {
      var _React$useState = React.useState(Boolean(window.GlitchJS && GlitchJS.isOnline)),
          isOnline = _React$useState[0],
          setIsOnline = _React$useState[1];

      var _React$useState2 = React.useState(function () { return new Date(); }),
          time = _React$useState2[0],
          setTime = _React$useState2[1];

      React.useEffect(function () {
        var tick = function () {
          setIsOnline(Boolean(window.GlitchJS && GlitchJS.isOnline));
          setTime(new Date());
        };
        var interval = setInterval(tick, 250);
        tick();
        return function () { clearInterval(interval); };
      }, []);

      var formatted = time.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });

      return h("div", { className: "status-badge " + (isOnline ? "online" : "offline"), role: "status", "aria-live": "polite", "aria-atomic": "true" },
        h("div", { className: "status-bg online" }),
        h("div", { className: "status-bg offline" }),
        h("div", { className: "status-content" },
          h("div", null, isOnline ? "Online" : "Offline"),
          h("div", { className: "status-time" }, formatted)
        )
      );
    }

    /* ------------------ AudioPlayer component ------------------ */
    function AudioPlayer() {
      // audioSources (kept as in your project)
      var audioSources = [
        'Inbox/Random Music/compressed/DJ XFOCOS - Topic - FUNK DO MALAME AMARELO (Slowed).mp3',
        'Inbox/Random Music/compressed/NXGHT! - Topic - BLUE HORIZON FUNK.mp3',
        'Inbox/ItΓÇÖs Just Not Okay/revenge (Sped Up).wav',
        'Inbox/ItΓÇÖs Just Not Okay/revenge.wav'
      ];

      var audioRef = React.useRef(null);

      /* Persistent state (lazy init) */
      var _React$useState3 = React.useState(function () {
        var saved = safeStorage.get("playbackRate", null);
        var n = saved !== null ? Number(saved) : 1;
        return isNaN(n) ? 1 : n;
      }),
          playbackRate = _React$useState3[0],
          setPlaybackRate = _React$useState3[1];

      var _React$useState4 = React.useState(function () {
        var saved = safeStorage.get("volume", null);
        var n = saved !== null ? Number(saved) : 1;
        return isNaN(n) ? 1 : n;
      }),
          volume = _React$useState4[0],
          setVolume = _React$useState4[1];

      React.useEffect(function () { safeStorage.set("playbackRate", playbackRate); }, [playbackRate]);
      React.useEffect(function () { safeStorage.set("volume", volume); }, [volume]);

      /* Audio state */
      var _React$useState5 = React.useState(null),
          currentSrc = _React$useState5[0],
          setCurrentSrc = _React$useState5[1];

      var _React$useState6 = React.useState(0),
          duration = _React$useState6[0],
          setDuration = _React$useState6[1];

      var _React$useState7 = React.useState(0),
          currentTime = _React$useState7[0],
          setCurrentTime = _React$useState7[1];

      var _React$useState8 = React.useState(false),
          isPlaying = _React$useState8[0],
          setIsPlaying = _React$useState8[1];

      var lastTrack = React.useRef(null);
      var recentTracks = React.useRef([]);

      var getSmartRandomTrack = function () {
        var pool = audioSources.filter(function (src) { return src !== lastTrack.current; });

        if (recentTracks.current.length >= audioSources.length - 1) {
          recentTracks.current = [];
        }

        pool = pool.filter(function (src) { return !recentTracks.current.includes(src); });

        var choice = pool[Math.floor(Math.random() * pool.length)];

        recentTracks.current.push(choice);
        lastTrack.current = choice;

        return choice;
      };

      var playRandom = function () {
        var next = getSmartRandomTrack();
        setCurrentSrc(next);
      };

      /* When currentSrc changes, set audio.src and play */
      React.useEffect(function () {
        var audio = audioRef.current;
        if (!audio) return;
        if (!currentSrc) return;
        audio.src = currentSrc;
        var p = audio.play();
        if (p && p.catch) p.catch(function () { /* autoplay blocked or other issue */ });
      }, [currentSrc]);

      /* Apply playbackRate + disable pitch preservation */
      React.useEffect(function () {
        var audio = audioRef.current;
        if (!audio) return;
        try {
          audio.playbackRate = playbackRate;
          if ('preservesPitch' in audio) audio.preservesPitch = false;
          if ('mozPreservesPitch' in audio) audio.mozPreservesPitch = false;
          if ('webkitPreservesPitch' in audio) audio.webkitPreservesPitch = false;
        } catch (e) {
          console.warn("apply playbackRate failed", e);
        }
      }, [playbackRate]);

      /* Apply volume */
      React.useEffect(function () {
        var audio = audioRef.current;
        if (audio) audio.volume = volume;
      }, [volume]);

      var onLoadedMetadata = function () {
        var audio = audioRef.current;
        if (!audio) return;
        setDuration(audio.duration || 0);
      };

      var onTimeUpdate = function () {
        var audio = audioRef.current;
        if (!audio) return;
        setCurrentTime(audio.currentTime);
      };

      var onPlay = function () { setIsPlaying(true); };
      var onPause = function () { setIsPlaying(false); };

      var onSeek = function (e) {
        var audio = audioRef.current;
        if (!audio) return;
        var value = Number(e.target.value);
        audio.currentTime = (value / 1000) * duration;
      };

      var seekPercent = duration ? (currentTime / duration) * 100 : 0;

      /* Ref callback: ensures we apply persisted settings immediately when audio element is created */
      var setAudioRef = function (el) {
        if (audioRef.current && audioRef.current !== el) {
          // cleanup previous listeners
          try {
            audioRef.current.removeEventListener('play', onPlay);
            audioRef.current.removeEventListener('pause', onPause);
            audioRef.current.removeEventListener('loadedmetadata', onLoadedMetadata);
            audioRef.current.removeEventListener('timeupdate', onTimeUpdate);
            audioRef.current.removeEventListener('ended', playRandom);
          } catch (e) { /* ignore */ }
        }

        audioRef.current = el;

        if (el) {
          try {
            el.volume = volume;
            el.playbackRate = playbackRate;
            if ('preservesPitch' in el) el.preservesPitch = false;
            if ('mozPreservesPitch' in el) el.mozPreservesPitch = false;
            if ('webkitPreservesPitch' in el) el.webkitPreservesPitch = false;
          } catch (e) {
            console.warn("Failed to apply audio settings on ref attach:", e);
          }

          // attach listeners
          el.addEventListener('play', onPlay);
          el.addEventListener('pause', onPause);
          el.addEventListener('loadedmetadata', onLoadedMetadata);
          el.addEventListener('timeupdate', onTimeUpdate);
          el.addEventListener('ended', playRandom);

          // set initial playing state
          setIsPlaying(!el.paused && !el.ended);
        }
      };

      /* Helper to format time */
      var fmt = function (sec) {
        if (!sec || isNaN(sec)) return "0:00";
        var m = Math.floor(sec / 60);
        var s = Math.floor(sec % 60);
        return m + ":" + (s < 10 ? "0" : "") + s;
      };

      /* Compute speed slider fill percent using new range (min 0.10, max 2.00) */
      var speedMin = 0.10;
      var speedMax = 2.00;
      var speedRange = speedMax - speedMin; // 1.9
      var speedFillPercent = ((playbackRate - speedMin) / speedRange) * 100;
      if (!isFinite(speedFillPercent)) speedFillPercent = 0;
      if (speedFillPercent < 0) speedFillPercent = 0;
      if (speedFillPercent > 100) speedFillPercent = 100;

      /* Build UI using React.createElement (h) */
      return h("div", null,
        // Floating top-right status (READ-ONLY) with correct tabIndex prop
        h("div", {
          className: "floating-status " + (isPlaying ? "status-playing" : "status-paused"),
          role: "status",
          "aria-hidden": "true",
          tabIndex: -1
        },
          h("div", { className: "status-dot", "aria-hidden": "true" }),
          h("div", { className: "status-text" }, isPlaying ? "Playing" : "Paused")
        ),

        h("h1", null, "React Radio"),

        h("div", { style: { marginBottom: 12 } }, h(OnlineStatus, null)),

        h("p", null, "Song playing: " + (currentSrc ? currentSrc.split("/").pop() : "None")),

        h("p", null, fmt(currentTime) + " / " + fmt(duration)),

        h("div", { style: { marginBottom: 12 } },
          h("button", { onClick: playRandom }, "Start Radio"),
          h("button", { onClick: function () { if (audioRef.current) audioRef.current.pause(); } }, "Pause"),
          h("button", { onClick: function () { if (audioRef.current) audioRef.current.play(); } }, "Resume"),
          h("button", { onClick: function () { if (audioRef.current) audioRef.current.currentTime = 0; } }, "⏮ Back"),
          h("button", { onClick: playRandom }, "⏭ Next")
        ),

        h("label", null, "Volume:"),
        h("input", {
          className: "volume-slider",
          type: "range",
          min: "0",
          max: "1",
          step: "0.01",
          value: volume,
          onChange: function (e) {
            var v = Number(e.target.value);
            setVolume(v);
            if (audioRef.current) audioRef.current.volume = v;
          },
          style: { width: "150px", marginLeft: "10px", "--seek-fill": (volume * 100) + "%" }
        }),

        h("br", null), h("br", null),

        h("label", null, "Speed/Pitch: ", h("span", null, playbackRate.toFixed(2) + "x")),
        h("input", {
          className: "volume-slider",
          type: "range",
          min: "0.10",
          max: "2.00",
          step: "0.05",
          value: playbackRate,
          onChange: function (e) {
            var v = Number(e.target.value);
            // clamp to valid range and round to step precision to avoid float drift
            v = Math.max(speedMin, Math.min(speedMax, Math.round(v / 0.05) * 0.05));
            setPlaybackRate(v);
            if (audioRef.current) {
              audioRef.current.playbackRate = v;
              if ('preservesPitch' in audioRef.current) audioRef.current.preservesPitch = false;
              if ('mozPreservesPitch' in audioRef.current) audioRef.current.mozPreservesPitch = false;
              if ('webkitPreservesPitch' in audioRef.current) audioRef.current.webkitPreservesPitch = false;
            }
          },
          style: { width: "150px", marginLeft: "10px", "--seek-fill": speedFillPercent + "%" }
        }),

        h("br", null), h("br", null),

        h("input", {
          className: "seek-slider",
          type: "range",
          min: "0",
          max: "1000",
          value: duration ? (currentTime / duration) * 1000 : 0,
          onChange: onSeek,
          style: { width: "100%", "--seek-fill": seekPercent + "%" }
        }),

        // audio element (kept)
        h("audio", { ref: setAudioRef })
      );
    }

    /* ------------------ App wrapper and render ------------------ */
    function App() {
      return h("div", null, h(AudioPlayer, null));
    }

    var root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(h(App, null));
  })();
  </script>
</body>
</html>
